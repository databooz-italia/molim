/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.8.2.0 (NJsonSchema v10.2.1.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class AccountsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAccounts(roleType: string | null | undefined): Observable<GetAccountsResponse> {
        let url_ = this.baseUrl + "/Accounts?";
        if (roleType !== undefined && roleType !== null)
            url_ += "roleType=" + encodeURIComponent("" + roleType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccounts(<any>response_);
                } catch (e) {
                    return <Observable<GetAccountsResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAccountsResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetAccounts(response: HttpResponseBase): Observable<GetAccountsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAccountsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAccountsResponse>(<any>null);
    }

    createAccount(request: CreateAccountRequest): Observable<FileResponse> {
        let url_ = this.baseUrl + "/Accounts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAccount(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAccount(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    updateAccount(id: number, request: UpdateAccountRequest): Observable<FileResponse> {
        let url_ = this.baseUrl + "/Accounts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAccount(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAccount(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    deleteAccount(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/Accounts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAccount(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAccount(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class AlgoritmiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAlgoritmi(): Observable<GetAlgoritmiResponse> {
        let url_ = this.baseUrl + "/Algoritmi";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAlgoritmi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAlgoritmi(<any>response_);
                } catch (e) {
                    return <Observable<GetAlgoritmiResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAlgoritmiResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetAlgoritmi(response: HttpResponseBase): Observable<GetAlgoritmiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAlgoritmiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAlgoritmiResponse>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class AuthClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    authenticate(request: AuthenticationRequest): Observable<AuthenticationResponse> {
        let url_ = this.baseUrl + "/Auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticationResponse>(<any>null);
    }

    resetPassword(request: ResetPasswordRequest): Observable<FileResponse> {
        let url_ = this.baseUrl + "/Auth/reset-pwd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class PatologieClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getPatologie(): Observable<GetPatologieResponse> {
        let url_ = this.baseUrl + "/Patologie";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPatologie(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPatologie(<any>response_);
                } catch (e) {
                    return <Observable<GetPatologieResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPatologieResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetPatologie(response: HttpResponseBase): Observable<GetPatologieResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPatologieResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPatologieResponse>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class PazientiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getPazienti(): Observable<GetPazientiResponse> {
        let url_ = this.baseUrl + "/Pazienti";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPazienti(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPazienti(<any>response_);
                } catch (e) {
                    return <Observable<GetPazientiResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPazientiResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetPazienti(response: HttpResponseBase): Observable<GetPazientiResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPazientiResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPazientiResponse>(<any>null);
    }

    createPaziente(request: CreatePazienteRequest): Observable<FileResponse> {
        let url_ = this.baseUrl + "/Pazienti";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePaziente(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePaziente(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePaziente(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    updatePaziente(id: string | null, request: UpdatePazienteRequest): Observable<FileResponse> {
        let url_ = this.baseUrl + "/Pazienti/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePaziente(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePaziente(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePaziente(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    deletePaziente(id: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/Pazienti/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePaziente(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePaziente(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePaziente(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getEsamiPaziente(idPaziente: string | null): Observable<GetEsamiPazienteResponse> {
        let url_ = this.baseUrl + "/Pazienti/{idPaziente}/esami";
        if (idPaziente === undefined || idPaziente === null)
            throw new Error("The parameter 'idPaziente' must be defined.");
        url_ = url_.replace("{idPaziente}", encodeURIComponent("" + idPaziente));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEsamiPaziente(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEsamiPaziente(<any>response_);
                } catch (e) {
                    return <Observable<GetEsamiPazienteResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEsamiPazienteResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetEsamiPaziente(response: HttpResponseBase): Observable<GetEsamiPazienteResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEsamiPazienteResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEsamiPazienteResponse>(<any>null);
    }

    saveEsame(idPaziente: string, esame: EsamePazienteDTO): Observable<number> {
        let url_ = this.baseUrl + "/Pazienti/{idPaziente}/esami";
        if (idPaziente === undefined || idPaziente === null)
            throw new Error("The parameter 'idPaziente' must be defined.");
        url_ = url_.replace("{idPaziente}", encodeURIComponent("" + idPaziente));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(esame);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveEsame(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveEsame(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processSaveEsame(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    downloadFileImmagine(idPaziente: string | null, idEsame: number, idImmagine: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/Pazienti/{idPaziente}/{idEsame}/immagini/{idImmagine}";
        if (idPaziente === undefined || idPaziente === null)
            throw new Error("The parameter 'idPaziente' must be defined.");
        url_ = url_.replace("{idPaziente}", encodeURIComponent("" + idPaziente));
        if (idEsame === undefined || idEsame === null)
            throw new Error("The parameter 'idEsame' must be defined.");
        url_ = url_.replace("{idEsame}", encodeURIComponent("" + idEsame));
        if (idImmagine === undefined || idImmagine === null)
            throw new Error("The parameter 'idImmagine' must be defined.");
        url_ = url_.replace("{idImmagine}", encodeURIComponent("" + idImmagine));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFileImmagine(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFileImmagine(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadFileImmagine(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    uploadFileEsame(idPaziente: string, idEsame: string, file: FileParameter | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/Pazienti/{idPaziente}/{idEsame}/immagini";
        if (idPaziente === undefined || idPaziente === null)
            throw new Error("The parameter 'idPaziente' must be defined.");
        url_ = url_.replace("{idPaziente}", encodeURIComponent("" + idPaziente));
        if (idEsame === undefined || idEsame === null)
            throw new Error("The parameter 'idEsame' must be defined.");
        url_ = url_.replace("{idEsame}", encodeURIComponent("" + idEsame));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadFileEsame(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadFileEsame(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processUploadFileEsame(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    uploadROIImmagine(idImmagine: string, file: FileParameter | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/Pazienti/{idImmagine}/roi";
        if (idImmagine === undefined || idImmagine === null)
            throw new Error("The parameter 'idImmagine' must be defined.");
        url_ = url_.replace("{idImmagine}", encodeURIComponent("" + idImmagine));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadROIImmagine(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadROIImmagine(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processUploadROIImmagine(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    saveFeatureEsame(idPaziente: string | null, idEsame: number, featureEsame: FeatureEsameDTO[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/Pazienti/{idPaziente}/{idEsame}/features";
        if (idPaziente === undefined || idPaziente === null)
            throw new Error("The parameter 'idPaziente' must be defined.");
        url_ = url_.replace("{idPaziente}", encodeURIComponent("" + idPaziente));
        if (idEsame === undefined || idEsame === null)
            throw new Error("The parameter 'idEsame' must be defined.");
        url_ = url_.replace("{idEsame}", encodeURIComponent("" + idEsame));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(featureEsame);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveFeatureEsame(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveFeatureEsame(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSaveFeatureEsame(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getPredizioniPaziente(idPaziente: string | null): Observable<GetPredizioniPazienteResponse> {
        let url_ = this.baseUrl + "/Pazienti/{idPaziente}/predizioni";
        if (idPaziente === undefined || idPaziente === null)
            throw new Error("The parameter 'idPaziente' must be defined.");
        url_ = url_.replace("{idPaziente}", encodeURIComponent("" + idPaziente));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPredizioniPaziente(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPredizioniPaziente(<any>response_);
                } catch (e) {
                    return <Observable<GetPredizioniPazienteResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPredizioniPazienteResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetPredizioniPaziente(response: HttpResponseBase): Observable<GetPredizioniPazienteResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPredizioniPazienteResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPredizioniPazienteResponse>(<any>null);
    }

    createPredizionePaziente(idPaziente: string, req: CreatePredizionePaziente): Observable<GetPredizioniPazienteResponse> {
        let url_ = this.baseUrl + "/Pazienti/{idPaziente}/predizioni";
        if (idPaziente === undefined || idPaziente === null)
            throw new Error("The parameter 'idPaziente' must be defined.");
        url_ = url_.replace("{idPaziente}", encodeURIComponent("" + idPaziente));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(req);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePredizionePaziente(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePredizionePaziente(<any>response_);
                } catch (e) {
                    return <Observable<GetPredizioniPazienteResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPredizioniPazienteResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePredizionePaziente(response: HttpResponseBase): Observable<GetPredizioniPazienteResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPredizioniPazienteResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPredizioniPazienteResponse>(<any>null);
    }

    getDiagnosiPaziente(idPaziente: string | null): Observable<GetDiagnosiPazienteResponse> {
        let url_ = this.baseUrl + "/Pazienti/{idPaziente}/diagnosi";
        if (idPaziente === undefined || idPaziente === null)
            throw new Error("The parameter 'idPaziente' must be defined.");
        url_ = url_.replace("{idPaziente}", encodeURIComponent("" + idPaziente));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDiagnosiPaziente(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDiagnosiPaziente(<any>response_);
                } catch (e) {
                    return <Observable<GetDiagnosiPazienteResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDiagnosiPazienteResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetDiagnosiPaziente(response: HttpResponseBase): Observable<GetDiagnosiPazienteResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDiagnosiPazienteResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDiagnosiPazienteResponse>(<any>null);
    }

    creaDiagnosiPaziente(idPaziente: string, diagnosi: CreaDiagnosiRequest): Observable<FileResponse> {
        let url_ = this.baseUrl + "/Pazienti/{idPaziente}/diagnosi";
        if (idPaziente === undefined || idPaziente === null)
            throw new Error("The parameter 'idPaziente' must be defined.");
        url_ = url_.replace("{idPaziente}", encodeURIComponent("" + idPaziente));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(diagnosi);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreaDiagnosiPaziente(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreaDiagnosiPaziente(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreaDiagnosiPaziente(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class VersionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getVersion(): Observable<string> {
        let url_ = this.baseUrl + "/Version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVersion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVersion(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetVersion(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

export class GetAccountsResponse implements IGetAccountsResponse {
    accounts?: AccountDTO[] | undefined;

    constructor(data?: IGetAccountsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["accounts"])) {
                this.accounts = [] as any;
                for (let item of _data["accounts"])
                    this.accounts!.push(AccountDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAccountsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetAccountsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.accounts)) {
            data["accounts"] = [];
            for (let item of this.accounts)
                data["accounts"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetAccountsResponse {
    accounts?: AccountDTO[] | undefined;
}

export class AccountDTO implements IAccountDTO {
    account_ID?: number;
    accountType_ID?: number | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    username?: string | undefined;
    roleType?: string | undefined;
    roleDescription?: string | undefined;
    availableBookings?: number | undefined;
    availableBookingsToDate?: Date | undefined;
    version?: number;

    constructor(data?: IAccountDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.account_ID = _data["account_ID"];
            this.accountType_ID = _data["accountType_ID"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.username = _data["username"];
            this.roleType = _data["roleType"];
            this.roleDescription = _data["roleDescription"];
            this.availableBookings = _data["availableBookings"];
            this.availableBookingsToDate = _data["availableBookingsToDate"] ? new Date(_data["availableBookingsToDate"].toString()) : <any>undefined;
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): AccountDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AccountDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["account_ID"] = this.account_ID;
        data["accountType_ID"] = this.accountType_ID;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["username"] = this.username;
        data["roleType"] = this.roleType;
        data["roleDescription"] = this.roleDescription;
        data["availableBookings"] = this.availableBookings;
        data["availableBookingsToDate"] = this.availableBookingsToDate ? this.availableBookingsToDate.toISOString() : <any>undefined;
        data["version"] = this.version;
        return data; 
    }
}

export interface IAccountDTO {
    account_ID?: number;
    accountType_ID?: number | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    username?: string | undefined;
    roleType?: string | undefined;
    roleDescription?: string | undefined;
    availableBookings?: number | undefined;
    availableBookingsToDate?: Date | undefined;
    version?: number;
}

export class CreateAccountRequest implements ICreateAccountRequest {
    roleType?: string | undefined;
    username?: string | undefined;
    lastName?: string | undefined;
    firstName?: string | undefined;
    password?: string | undefined;
    bookings?: number | undefined;
    accountType_ID?: number | undefined;
    bookingsToDate?: Date | undefined;

    constructor(data?: ICreateAccountRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleType = _data["roleType"];
            this.username = _data["username"];
            this.lastName = _data["lastName"];
            this.firstName = _data["firstName"];
            this.password = _data["password"];
            this.bookings = _data["bookings"];
            this.accountType_ID = _data["accountType_ID"];
            this.bookingsToDate = _data["bookingsToDate"] ? new Date(_data["bookingsToDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateAccountRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAccountRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleType"] = this.roleType;
        data["username"] = this.username;
        data["lastName"] = this.lastName;
        data["firstName"] = this.firstName;
        data["password"] = this.password;
        data["bookings"] = this.bookings;
        data["accountType_ID"] = this.accountType_ID;
        data["bookingsToDate"] = this.bookingsToDate ? this.bookingsToDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ICreateAccountRequest {
    roleType?: string | undefined;
    username?: string | undefined;
    lastName?: string | undefined;
    firstName?: string | undefined;
    password?: string | undefined;
    bookings?: number | undefined;
    accountType_ID?: number | undefined;
    bookingsToDate?: Date | undefined;
}

export class UpdateAccountRequest implements IUpdateAccountRequest {
    username?: string | undefined;
    password?: string | undefined;
    lastName?: string | undefined;
    firstName?: string | undefined;
    bookings?: number | undefined;
    bookingsToDate?: Date | undefined;
    accountType_ID?: number | undefined;
    version?: number;

    constructor(data?: IUpdateAccountRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
            this.lastName = _data["lastName"];
            this.firstName = _data["firstName"];
            this.bookings = _data["bookings"];
            this.bookingsToDate = _data["bookingsToDate"] ? new Date(_data["bookingsToDate"].toString()) : <any>undefined;
            this.accountType_ID = _data["accountType_ID"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateAccountRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAccountRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        data["lastName"] = this.lastName;
        data["firstName"] = this.firstName;
        data["bookings"] = this.bookings;
        data["bookingsToDate"] = this.bookingsToDate ? this.bookingsToDate.toISOString() : <any>undefined;
        data["accountType_ID"] = this.accountType_ID;
        data["version"] = this.version;
        return data; 
    }
}

export interface IUpdateAccountRequest {
    username?: string | undefined;
    password?: string | undefined;
    lastName?: string | undefined;
    firstName?: string | undefined;
    bookings?: number | undefined;
    bookingsToDate?: Date | undefined;
    accountType_ID?: number | undefined;
    version?: number;
}

export class GetAlgoritmiResponse implements IGetAlgoritmiResponse {
    algoritmi?: AlgoritmoDTO[] | undefined;

    constructor(data?: IGetAlgoritmiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["algoritmi"])) {
                this.algoritmi = [] as any;
                for (let item of _data["algoritmi"])
                    this.algoritmi!.push(AlgoritmoDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAlgoritmiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetAlgoritmiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.algoritmi)) {
            data["algoritmi"] = [];
            for (let item of this.algoritmi)
                data["algoritmi"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetAlgoritmiResponse {
    algoritmi?: AlgoritmoDTO[] | undefined;
}

export class AlgoritmoDTO implements IAlgoritmoDTO {
    id?: number;
    idPatologia?: string | undefined;
    idTipoEsame?: string | undefined;
    descrizione?: string | undefined;
    endpointRest?: string | undefined;
    tipo?: string | undefined;
    oggettoDiPredizione?: string | undefined;
    features?: FeatureAlgoritmoDTO[] | undefined;

    constructor(data?: IAlgoritmoDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.idPatologia = _data["idPatologia"];
            this.idTipoEsame = _data["idTipoEsame"];
            this.descrizione = _data["descrizione"];
            this.endpointRest = _data["endpointRest"];
            this.tipo = _data["tipo"];
            this.oggettoDiPredizione = _data["oggettoDiPredizione"];
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(FeatureAlgoritmoDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AlgoritmoDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AlgoritmoDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["idPatologia"] = this.idPatologia;
        data["idTipoEsame"] = this.idTipoEsame;
        data["descrizione"] = this.descrizione;
        data["endpointRest"] = this.endpointRest;
        data["tipo"] = this.tipo;
        data["oggettoDiPredizione"] = this.oggettoDiPredizione;
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAlgoritmoDTO {
    id?: number;
    idPatologia?: string | undefined;
    idTipoEsame?: string | undefined;
    descrizione?: string | undefined;
    endpointRest?: string | undefined;
    tipo?: string | undefined;
    oggettoDiPredizione?: string | undefined;
    features?: FeatureAlgoritmoDTO[] | undefined;
}

export class FeatureAlgoritmoDTO implements IFeatureAlgoritmoDTO {
    idAlgoritmo?: number;
    idFeature?: number;
    obbligatorio?: boolean;

    constructor(data?: IFeatureAlgoritmoDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idAlgoritmo = _data["idAlgoritmo"];
            this.idFeature = _data["idFeature"];
            this.obbligatorio = _data["obbligatorio"];
        }
    }

    static fromJS(data: any): FeatureAlgoritmoDTO {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureAlgoritmoDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idAlgoritmo"] = this.idAlgoritmo;
        data["idFeature"] = this.idFeature;
        data["obbligatorio"] = this.obbligatorio;
        return data; 
    }
}

export interface IFeatureAlgoritmoDTO {
    idAlgoritmo?: number;
    idFeature?: number;
    obbligatorio?: boolean;
}

export class AuthenticationResponse implements IAuthenticationResponse {
    shortTermToken?: string | undefined;
    longTermToken?: string | undefined;
    username?: string | undefined;
    account_ID?: number;
    roleType?: string | undefined;
    permissions?: string[] | undefined;
    resetPassword?: boolean;

    constructor(data?: IAuthenticationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shortTermToken = _data["shortTermToken"];
            this.longTermToken = _data["longTermToken"];
            this.username = _data["username"];
            this.account_ID = _data["account_ID"];
            this.roleType = _data["roleType"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
            this.resetPassword = _data["resetPassword"];
        }
    }

    static fromJS(data: any): AuthenticationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shortTermToken"] = this.shortTermToken;
        data["longTermToken"] = this.longTermToken;
        data["username"] = this.username;
        data["account_ID"] = this.account_ID;
        data["roleType"] = this.roleType;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        data["resetPassword"] = this.resetPassword;
        return data; 
    }
}

export interface IAuthenticationResponse {
    shortTermToken?: string | undefined;
    longTermToken?: string | undefined;
    username?: string | undefined;
    account_ID?: number;
    roleType?: string | undefined;
    permissions?: string[] | undefined;
    resetPassword?: boolean;
}

export class AuthenticationRequest implements IAuthenticationRequest {
    username?: string | undefined;
    password?: string | undefined;

    constructor(data?: IAuthenticationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): AuthenticationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        return data; 
    }
}

export interface IAuthenticationRequest {
    username?: string | undefined;
    password?: string | undefined;
}

export class ResetPasswordRequest implements IResetPasswordRequest {
    oldPassword?: string | undefined;
    newPassword?: string | undefined;

    constructor(data?: IResetPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.oldPassword = _data["oldPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oldPassword"] = this.oldPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }
}

export interface IResetPasswordRequest {
    oldPassword?: string | undefined;
    newPassword?: string | undefined;
}

export class GetPatologieResponse implements IGetPatologieResponse {
    patologie?: PatologiaDTO[] | undefined;

    constructor(data?: IGetPatologieResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["patologie"])) {
                this.patologie = [] as any;
                for (let item of _data["patologie"])
                    this.patologie!.push(PatologiaDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPatologieResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetPatologieResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.patologie)) {
            data["patologie"] = [];
            for (let item of this.patologie)
                data["patologie"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetPatologieResponse {
    patologie?: PatologiaDTO[] | undefined;
}

export class PatologiaDTO implements IPatologiaDTO {
    id?: string | undefined;
    descrizione?: string | undefined;
    tipiEsami?: TipologiaEsameDTO[] | undefined;

    constructor(data?: IPatologiaDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descrizione = _data["descrizione"];
            if (Array.isArray(_data["tipiEsami"])) {
                this.tipiEsami = [] as any;
                for (let item of _data["tipiEsami"])
                    this.tipiEsami!.push(TipologiaEsameDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PatologiaDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PatologiaDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descrizione"] = this.descrizione;
        if (Array.isArray(this.tipiEsami)) {
            data["tipiEsami"] = [];
            for (let item of this.tipiEsami)
                data["tipiEsami"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPatologiaDTO {
    id?: string | undefined;
    descrizione?: string | undefined;
    tipiEsami?: TipologiaEsameDTO[] | undefined;
}

export class TipologiaEsameDTO implements ITipologiaEsameDTO {
    idTipologiaEsame?: string | undefined;
    idPatologia?: string | undefined;
    descrizione?: string | undefined;
    richiedeImmagini?: boolean;
    features?: FeatureDTO[] | undefined;

    constructor(data?: ITipologiaEsameDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idTipologiaEsame = _data["idTipologiaEsame"];
            this.idPatologia = _data["idPatologia"];
            this.descrizione = _data["descrizione"];
            this.richiedeImmagini = _data["richiedeImmagini"];
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(FeatureDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TipologiaEsameDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TipologiaEsameDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idTipologiaEsame"] = this.idTipologiaEsame;
        data["idPatologia"] = this.idPatologia;
        data["descrizione"] = this.descrizione;
        data["richiedeImmagini"] = this.richiedeImmagini;
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITipologiaEsameDTO {
    idTipologiaEsame?: string | undefined;
    idPatologia?: string | undefined;
    descrizione?: string | undefined;
    richiedeImmagini?: boolean;
    features?: FeatureDTO[] | undefined;
}

export class FeatureDTO implements IFeatureDTO {
    id?: number;
    idFeature?: string | undefined;
    idPatologia?: string | undefined;
    idTipologiaEsame?: string | undefined;
    descrizionePatologia?: string | undefined;
    descrizioneTipologiaEsame?: string | undefined;
    tipoValore?: string | undefined;
    valoreMinimo?: number | undefined;
    valoreMassimo?: number | undefined;
    valoriAmmessi?: { [key: string]: string; } | undefined;

    constructor(data?: IFeatureDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.idFeature = _data["idFeature"];
            this.idPatologia = _data["idPatologia"];
            this.idTipologiaEsame = _data["idTipologiaEsame"];
            this.descrizionePatologia = _data["descrizionePatologia"];
            this.descrizioneTipologiaEsame = _data["descrizioneTipologiaEsame"];
            this.tipoValore = _data["tipoValore"];
            this.valoreMinimo = _data["valoreMinimo"];
            this.valoreMassimo = _data["valoreMassimo"];
            if (_data["valoriAmmessi"]) {
                this.valoriAmmessi = {} as any;
                for (let key in _data["valoriAmmessi"]) {
                    if (_data["valoriAmmessi"].hasOwnProperty(key))
                        this.valoriAmmessi![key] = _data["valoriAmmessi"][key];
                }
            }
        }
    }

    static fromJS(data: any): FeatureDTO {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["idFeature"] = this.idFeature;
        data["idPatologia"] = this.idPatologia;
        data["idTipologiaEsame"] = this.idTipologiaEsame;
        data["descrizionePatologia"] = this.descrizionePatologia;
        data["descrizioneTipologiaEsame"] = this.descrizioneTipologiaEsame;
        data["tipoValore"] = this.tipoValore;
        data["valoreMinimo"] = this.valoreMinimo;
        data["valoreMassimo"] = this.valoreMassimo;
        if (this.valoriAmmessi) {
            data["valoriAmmessi"] = {};
            for (let key in this.valoriAmmessi) {
                if (this.valoriAmmessi.hasOwnProperty(key))
                    data["valoriAmmessi"][key] = this.valoriAmmessi[key];
            }
        }
        return data; 
    }
}

export interface IFeatureDTO {
    id?: number;
    idFeature?: string | undefined;
    idPatologia?: string | undefined;
    idTipologiaEsame?: string | undefined;
    descrizionePatologia?: string | undefined;
    descrizioneTipologiaEsame?: string | undefined;
    tipoValore?: string | undefined;
    valoreMinimo?: number | undefined;
    valoreMassimo?: number | undefined;
    valoriAmmessi?: { [key: string]: string; } | undefined;
}

export class GetPazientiResponse implements IGetPazientiResponse {
    pazienti?: PazienteDTO[] | undefined;

    constructor(data?: IGetPazientiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["pazienti"])) {
                this.pazienti = [] as any;
                for (let item of _data["pazienti"])
                    this.pazienti!.push(PazienteDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPazientiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetPazientiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.pazienti)) {
            data["pazienti"] = [];
            for (let item of this.pazienti)
                data["pazienti"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetPazientiResponse {
    pazienti?: PazienteDTO[] | undefined;
}

export class PazienteDTO implements IPazienteDTO {
    idPaziente?: string | undefined;
    nomePaziente?: string | undefined;
    cognomePaziente?: string | undefined;
    annoNascita?: number | undefined;
    sesso?: string | undefined;
    city?: string | undefined;
    codiceFiscale?: string | undefined;
    indirizzo?: string | undefined;
    indirizzoMail?: string | undefined;
    numeroCellulare?: string | undefined;
    education?: number | undefined;

    constructor(data?: IPazienteDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idPaziente = _data["idPaziente"];
            this.nomePaziente = _data["nomePaziente"];
            this.cognomePaziente = _data["cognomePaziente"];
            this.annoNascita = _data["annoNascita"];
            this.sesso = _data["sesso"];
            this.city = _data["city"];
            this.codiceFiscale = _data["codiceFiscale"];
            this.indirizzo = _data["indirizzo"];
            this.indirizzoMail = _data["indirizzoMail"];
            this.numeroCellulare = _data["numeroCellulare"];
            this.education = _data["education"];
        }
    }

    static fromJS(data: any): PazienteDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PazienteDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idPaziente"] = this.idPaziente;
        data["nomePaziente"] = this.nomePaziente;
        data["cognomePaziente"] = this.cognomePaziente;
        data["annoNascita"] = this.annoNascita;
        data["sesso"] = this.sesso;
        data["city"] = this.city;
        data["codiceFiscale"] = this.codiceFiscale;
        data["indirizzo"] = this.indirizzo;
        data["indirizzoMail"] = this.indirizzoMail;
        data["numeroCellulare"] = this.numeroCellulare;
        data["education"] = this.education;
        return data; 
    }
}

export interface IPazienteDTO {
    idPaziente?: string | undefined;
    nomePaziente?: string | undefined;
    cognomePaziente?: string | undefined;
    annoNascita?: number | undefined;
    sesso?: string | undefined;
    city?: string | undefined;
    codiceFiscale?: string | undefined;
    indirizzo?: string | undefined;
    indirizzoMail?: string | undefined;
    numeroCellulare?: string | undefined;
    education?: number | undefined;
}

export class CreatePazienteRequest implements ICreatePazienteRequest {
    idPaziente?: string | undefined;
    nomePaziente?: string | undefined;
    cognomePaziente?: string | undefined;
    annoNascita?: number | undefined;
    sesso?: string | undefined;
    city?: string | undefined;
    codiceFiscale?: string | undefined;
    indirizzo?: string | undefined;
    indirizzoMail?: string | undefined;
    numeroCellulare?: string | undefined;
    education?: number | undefined;

    constructor(data?: ICreatePazienteRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idPaziente = _data["idPaziente"];
            this.nomePaziente = _data["nomePaziente"];
            this.cognomePaziente = _data["cognomePaziente"];
            this.annoNascita = _data["annoNascita"];
            this.sesso = _data["sesso"];
            this.city = _data["city"];
            this.codiceFiscale = _data["codiceFiscale"];
            this.indirizzo = _data["indirizzo"];
            this.indirizzoMail = _data["indirizzoMail"];
            this.numeroCellulare = _data["numeroCellulare"];
            this.education = _data["education"];
        }
    }

    static fromJS(data: any): CreatePazienteRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePazienteRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idPaziente"] = this.idPaziente;
        data["nomePaziente"] = this.nomePaziente;
        data["cognomePaziente"] = this.cognomePaziente;
        data["annoNascita"] = this.annoNascita;
        data["sesso"] = this.sesso;
        data["city"] = this.city;
        data["codiceFiscale"] = this.codiceFiscale;
        data["indirizzo"] = this.indirizzo;
        data["indirizzoMail"] = this.indirizzoMail;
        data["numeroCellulare"] = this.numeroCellulare;
        data["education"] = this.education;
        return data; 
    }
}

export interface ICreatePazienteRequest {
    idPaziente?: string | undefined;
    nomePaziente?: string | undefined;
    cognomePaziente?: string | undefined;
    annoNascita?: number | undefined;
    sesso?: string | undefined;
    city?: string | undefined;
    codiceFiscale?: string | undefined;
    indirizzo?: string | undefined;
    indirizzoMail?: string | undefined;
    numeroCellulare?: string | undefined;
    education?: number | undefined;
}

export class UpdatePazienteRequest implements IUpdatePazienteRequest {
    nomePaziente?: string | undefined;
    cognomePaziente?: string | undefined;
    annoNascita?: number | undefined;
    sesso?: string | undefined;
    city?: string | undefined;
    codiceFiscale?: string | undefined;
    indirizzo?: string | undefined;
    indirizzoMail?: string | undefined;
    numeroCellulare?: string | undefined;
    education?: number | undefined;

    constructor(data?: IUpdatePazienteRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nomePaziente = _data["nomePaziente"];
            this.cognomePaziente = _data["cognomePaziente"];
            this.annoNascita = _data["annoNascita"];
            this.sesso = _data["sesso"];
            this.city = _data["city"];
            this.codiceFiscale = _data["codiceFiscale"];
            this.indirizzo = _data["indirizzo"];
            this.indirizzoMail = _data["indirizzoMail"];
            this.numeroCellulare = _data["numeroCellulare"];
            this.education = _data["education"];
        }
    }

    static fromJS(data: any): UpdatePazienteRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePazienteRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nomePaziente"] = this.nomePaziente;
        data["cognomePaziente"] = this.cognomePaziente;
        data["annoNascita"] = this.annoNascita;
        data["sesso"] = this.sesso;
        data["city"] = this.city;
        data["codiceFiscale"] = this.codiceFiscale;
        data["indirizzo"] = this.indirizzo;
        data["indirizzoMail"] = this.indirizzoMail;
        data["numeroCellulare"] = this.numeroCellulare;
        data["education"] = this.education;
        return data; 
    }
}

export interface IUpdatePazienteRequest {
    nomePaziente?: string | undefined;
    cognomePaziente?: string | undefined;
    annoNascita?: number | undefined;
    sesso?: string | undefined;
    city?: string | undefined;
    codiceFiscale?: string | undefined;
    indirizzo?: string | undefined;
    indirizzoMail?: string | undefined;
    numeroCellulare?: string | undefined;
    education?: number | undefined;
}

export class GetEsamiPazienteResponse implements IGetEsamiPazienteResponse {
    esamiPaziente?: { [key: string]: EsamePazienteDTO[]; } | undefined;

    constructor(data?: IGetEsamiPazienteResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["esamiPaziente"]) {
                this.esamiPaziente = {} as any;
                for (let key in _data["esamiPaziente"]) {
                    if (_data["esamiPaziente"].hasOwnProperty(key))
                        this.esamiPaziente![key] = _data["esamiPaziente"][key] ? _data["esamiPaziente"][key].map((i: any) => EsamePazienteDTO.fromJS(i)) : [];
                }
            }
        }
    }

    static fromJS(data: any): GetEsamiPazienteResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetEsamiPazienteResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.esamiPaziente) {
            data["esamiPaziente"] = {};
            for (let key in this.esamiPaziente) {
                if (this.esamiPaziente.hasOwnProperty(key))
                    data["esamiPaziente"][key] = this.esamiPaziente[key];
            }
        }
        return data; 
    }
}

export interface IGetEsamiPazienteResponse {
    esamiPaziente?: { [key: string]: EsamePazienteDTO[]; } | undefined;
}

export class EsamePazienteDTO implements IEsamePazienteDTO {
    idEsame?: number;
    data?: Date;
    richiedeImmagini?: boolean;
    idPaziente?: string | undefined;
    descrizionePaziente?: string | undefined;
    idPatologia?: string | undefined;
    descrizionePatologia?: string | undefined;
    idTipoEsame?: string | undefined;
    descrizioneTipoEsame?: string | undefined;
    immagini?: ImmagineDTO[] | undefined;
    features?: FeatureEsameDTO[] | undefined;

    constructor(data?: IEsamePazienteDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idEsame = _data["idEsame"];
            this.data = _data["data"] ? new Date(_data["data"].toString()) : <any>undefined;
            this.richiedeImmagini = _data["richiedeImmagini"];
            this.idPaziente = _data["idPaziente"];
            this.descrizionePaziente = _data["descrizionePaziente"];
            this.idPatologia = _data["idPatologia"];
            this.descrizionePatologia = _data["descrizionePatologia"];
            this.idTipoEsame = _data["idTipoEsame"];
            this.descrizioneTipoEsame = _data["descrizioneTipoEsame"];
            if (Array.isArray(_data["immagini"])) {
                this.immagini = [] as any;
                for (let item of _data["immagini"])
                    this.immagini!.push(ImmagineDTO.fromJS(item));
            }
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(FeatureEsameDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EsamePazienteDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EsamePazienteDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idEsame"] = this.idEsame;
        data["data"] = this.data ? this.data.toISOString() : <any>undefined;
        data["richiedeImmagini"] = this.richiedeImmagini;
        data["idPaziente"] = this.idPaziente;
        data["descrizionePaziente"] = this.descrizionePaziente;
        data["idPatologia"] = this.idPatologia;
        data["descrizionePatologia"] = this.descrizionePatologia;
        data["idTipoEsame"] = this.idTipoEsame;
        data["descrizioneTipoEsame"] = this.descrizioneTipoEsame;
        if (Array.isArray(this.immagini)) {
            data["immagini"] = [];
            for (let item of this.immagini)
                data["immagini"].push(item.toJSON());
        }
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEsamePazienteDTO {
    idEsame?: number;
    data?: Date;
    richiedeImmagini?: boolean;
    idPaziente?: string | undefined;
    descrizionePaziente?: string | undefined;
    idPatologia?: string | undefined;
    descrizionePatologia?: string | undefined;
    idTipoEsame?: string | undefined;
    descrizioneTipoEsame?: string | undefined;
    immagini?: ImmagineDTO[] | undefined;
    features?: FeatureEsameDTO[] | undefined;
}

export class ImmagineDTO implements IImmagineDTO {
    id?: number;
    idEsame?: number;
    nome?: string | undefined;
    dimensione?: number;
    dataCaricamento?: Date;
    features?: FeatureEsameDTO[] | undefined;
    regioniDiInteresse?: RegionOfInterestDTO[] | undefined;

    constructor(data?: IImmagineDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.idEsame = _data["idEsame"];
            this.nome = _data["nome"];
            this.dimensione = _data["dimensione"];
            this.dataCaricamento = _data["dataCaricamento"] ? new Date(_data["dataCaricamento"].toString()) : <any>undefined;
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(FeatureEsameDTO.fromJS(item));
            }
            if (Array.isArray(_data["regioniDiInteresse"])) {
                this.regioniDiInteresse = [] as any;
                for (let item of _data["regioniDiInteresse"])
                    this.regioniDiInteresse!.push(RegionOfInterestDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ImmagineDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ImmagineDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["idEsame"] = this.idEsame;
        data["nome"] = this.nome;
        data["dimensione"] = this.dimensione;
        data["dataCaricamento"] = this.dataCaricamento ? this.dataCaricamento.toISOString() : <any>undefined;
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        if (Array.isArray(this.regioniDiInteresse)) {
            data["regioniDiInteresse"] = [];
            for (let item of this.regioniDiInteresse)
                data["regioniDiInteresse"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IImmagineDTO {
    id?: number;
    idEsame?: number;
    nome?: string | undefined;
    dimensione?: number;
    dataCaricamento?: Date;
    features?: FeatureEsameDTO[] | undefined;
    regioniDiInteresse?: RegionOfInterestDTO[] | undefined;
}

export class FeatureEsameDTO implements IFeatureEsameDTO {
    idFeature?: string | undefined;
    descrizione?: string | undefined;
    idImmagine?: number;
    idROI?: number;
    dataInizioValidita?: Date | undefined;
    dataFineValidita?: Date | undefined;
    valore?: any | undefined;
    tipoValore?: string | undefined;

    constructor(data?: IFeatureEsameDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idFeature = _data["idFeature"];
            this.descrizione = _data["descrizione"];
            this.idImmagine = _data["idImmagine"];
            this.idROI = _data["idROI"];
            this.dataInizioValidita = _data["dataInizioValidita"] ? new Date(_data["dataInizioValidita"].toString()) : <any>undefined;
            this.dataFineValidita = _data["dataFineValidita"] ? new Date(_data["dataFineValidita"].toString()) : <any>undefined;
            this.valore = _data["valore"];
            this.tipoValore = _data["tipoValore"];
        }
    }

    static fromJS(data: any): FeatureEsameDTO {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureEsameDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idFeature"] = this.idFeature;
        data["descrizione"] = this.descrizione;
        data["idImmagine"] = this.idImmagine;
        data["idROI"] = this.idROI;
        data["dataInizioValidita"] = this.dataInizioValidita ? this.dataInizioValidita.toISOString() : <any>undefined;
        data["dataFineValidita"] = this.dataFineValidita ? this.dataFineValidita.toISOString() : <any>undefined;
        data["valore"] = this.valore;
        data["tipoValore"] = this.tipoValore;
        return data; 
    }
}

export interface IFeatureEsameDTO {
    idFeature?: string | undefined;
    descrizione?: string | undefined;
    idImmagine?: number;
    idROI?: number;
    dataInizioValidita?: Date | undefined;
    dataFineValidita?: Date | undefined;
    valore?: any | undefined;
    tipoValore?: string | undefined;
}

export class RegionOfInterestDTO implements IRegionOfInterestDTO {
    id?: number;
    nomeFile?: string | undefined;
    dimensione?: number;
    idImmagine?: number;
    nomeFileImmagine?: string | undefined;
    features?: FeatureEsameDTO[] | undefined;

    constructor(data?: IRegionOfInterestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nomeFile = _data["nomeFile"];
            this.dimensione = _data["dimensione"];
            this.idImmagine = _data["idImmagine"];
            this.nomeFileImmagine = _data["nomeFileImmagine"];
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(FeatureEsameDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RegionOfInterestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RegionOfInterestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nomeFile"] = this.nomeFile;
        data["dimensione"] = this.dimensione;
        data["idImmagine"] = this.idImmagine;
        data["nomeFileImmagine"] = this.nomeFileImmagine;
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRegionOfInterestDTO {
    id?: number;
    nomeFile?: string | undefined;
    dimensione?: number;
    idImmagine?: number;
    nomeFileImmagine?: string | undefined;
    features?: FeatureEsameDTO[] | undefined;
}

export class GetPredizioniPazienteResponse implements IGetPredizioniPazienteResponse {
    predizioniPaziente?: { [key: string]: PredizioneDTO[]; } | undefined;

    constructor(data?: IGetPredizioniPazienteResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["predizioniPaziente"]) {
                this.predizioniPaziente = {} as any;
                for (let key in _data["predizioniPaziente"]) {
                    if (_data["predizioniPaziente"].hasOwnProperty(key))
                        this.predizioniPaziente![key] = _data["predizioniPaziente"][key] ? _data["predizioniPaziente"][key].map((i: any) => PredizioneDTO.fromJS(i)) : [];
                }
            }
        }
    }

    static fromJS(data: any): GetPredizioniPazienteResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetPredizioniPazienteResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.predizioniPaziente) {
            data["predizioniPaziente"] = {};
            for (let key in this.predizioniPaziente) {
                if (this.predizioniPaziente.hasOwnProperty(key))
                    data["predizioniPaziente"][key] = this.predizioniPaziente[key];
            }
        }
        return data; 
    }
}

export interface IGetPredizioniPazienteResponse {
    predizioniPaziente?: { [key: string]: PredizioneDTO[]; } | undefined;
}

export class PredizioneDTO implements IPredizioneDTO {
    id?: number;
    idPaziente?: string | undefined;
    idPatologia?: string | undefined;
    idAlgoritmo?: number;
    dataRichiesta?: Date;
    descrizionePatologia?: string | undefined;
    descrizioneAlgoritmo?: string | undefined;
    descrizionePaziente?: string | undefined;
    esitoPredizione?: string | undefined;
    esito?: string | undefined;

    constructor(data?: IPredizioneDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.idPaziente = _data["idPaziente"];
            this.idPatologia = _data["idPatologia"];
            this.idAlgoritmo = _data["idAlgoritmo"];
            this.dataRichiesta = _data["dataRichiesta"] ? new Date(_data["dataRichiesta"].toString()) : <any>undefined;
            this.descrizionePatologia = _data["descrizionePatologia"];
            this.descrizioneAlgoritmo = _data["descrizioneAlgoritmo"];
            this.descrizionePaziente = _data["descrizionePaziente"];
            this.esitoPredizione = _data["esitoPredizione"];
            this.esito = _data["esito"];
        }
    }

    static fromJS(data: any): PredizioneDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PredizioneDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["idPaziente"] = this.idPaziente;
        data["idPatologia"] = this.idPatologia;
        data["idAlgoritmo"] = this.idAlgoritmo;
        data["dataRichiesta"] = this.dataRichiesta ? this.dataRichiesta.toISOString() : <any>undefined;
        data["descrizionePatologia"] = this.descrizionePatologia;
        data["descrizioneAlgoritmo"] = this.descrizioneAlgoritmo;
        data["descrizionePaziente"] = this.descrizionePaziente;
        data["esitoPredizione"] = this.esitoPredizione;
        data["esito"] = this.esito;
        return data; 
    }
}

export interface IPredizioneDTO {
    id?: number;
    idPaziente?: string | undefined;
    idPatologia?: string | undefined;
    idAlgoritmo?: number;
    dataRichiesta?: Date;
    descrizionePatologia?: string | undefined;
    descrizioneAlgoritmo?: string | undefined;
    descrizionePaziente?: string | undefined;
    esitoPredizione?: string | undefined;
    esito?: string | undefined;
}

export class CreatePredizionePaziente implements ICreatePredizionePaziente {
    idAlgoritmo?: number;
    idPaziente?: string | undefined;
    idImmagine?: number;
    idRegioneDiInteresse?: number | undefined;
    idPatologia?: string | undefined;

    constructor(data?: ICreatePredizionePaziente) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idAlgoritmo = _data["idAlgoritmo"];
            this.idPaziente = _data["idPaziente"];
            this.idImmagine = _data["idImmagine"];
            this.idRegioneDiInteresse = _data["idRegioneDiInteresse"];
            this.idPatologia = _data["idPatologia"];
        }
    }

    static fromJS(data: any): CreatePredizionePaziente {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePredizionePaziente();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idAlgoritmo"] = this.idAlgoritmo;
        data["idPaziente"] = this.idPaziente;
        data["idImmagine"] = this.idImmagine;
        data["idRegioneDiInteresse"] = this.idRegioneDiInteresse;
        data["idPatologia"] = this.idPatologia;
        return data; 
    }
}

export interface ICreatePredizionePaziente {
    idAlgoritmo?: number;
    idPaziente?: string | undefined;
    idImmagine?: number;
    idRegioneDiInteresse?: number | undefined;
    idPatologia?: string | undefined;
}

export class GetDiagnosiPazienteResponse implements IGetDiagnosiPazienteResponse {
    diagnosiPaziente?: { [key: string]: DiagnosiDTO[]; } | undefined;

    constructor(data?: IGetDiagnosiPazienteResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["diagnosiPaziente"]) {
                this.diagnosiPaziente = {} as any;
                for (let key in _data["diagnosiPaziente"]) {
                    if (_data["diagnosiPaziente"].hasOwnProperty(key))
                        this.diagnosiPaziente![key] = _data["diagnosiPaziente"][key] ? _data["diagnosiPaziente"][key].map((i: any) => DiagnosiDTO.fromJS(i)) : [];
                }
            }
        }
    }

    static fromJS(data: any): GetDiagnosiPazienteResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetDiagnosiPazienteResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.diagnosiPaziente) {
            data["diagnosiPaziente"] = {};
            for (let key in this.diagnosiPaziente) {
                if (this.diagnosiPaziente.hasOwnProperty(key))
                    data["diagnosiPaziente"][key] = this.diagnosiPaziente[key];
            }
        }
        return data; 
    }
}

export interface IGetDiagnosiPazienteResponse {
    diagnosiPaziente?: { [key: string]: DiagnosiDTO[]; } | undefined;
}

export class DiagnosiDTO implements IDiagnosiDTO {
    id?: number;
    idPaziente?: string | undefined;
    idPatologia?: string | undefined;
    data?: Date;
    descrizionePatologia?: string | undefined;
    descrizionePaziente?: string | undefined;
    esito?: string | undefined;

    constructor(data?: IDiagnosiDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.idPaziente = _data["idPaziente"];
            this.idPatologia = _data["idPatologia"];
            this.data = _data["data"] ? new Date(_data["data"].toString()) : <any>undefined;
            this.descrizionePatologia = _data["descrizionePatologia"];
            this.descrizionePaziente = _data["descrizionePaziente"];
            this.esito = _data["esito"];
        }
    }

    static fromJS(data: any): DiagnosiDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DiagnosiDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["idPaziente"] = this.idPaziente;
        data["idPatologia"] = this.idPatologia;
        data["data"] = this.data ? this.data.toISOString() : <any>undefined;
        data["descrizionePatologia"] = this.descrizionePatologia;
        data["descrizionePaziente"] = this.descrizionePaziente;
        data["esito"] = this.esito;
        return data; 
    }
}

export interface IDiagnosiDTO {
    id?: number;
    idPaziente?: string | undefined;
    idPatologia?: string | undefined;
    data?: Date;
    descrizionePatologia?: string | undefined;
    descrizionePaziente?: string | undefined;
    esito?: string | undefined;
}

export class CreaDiagnosiRequest implements ICreaDiagnosiRequest {
    idPaziente?: string | undefined;
    idPatologia?: string | undefined;
    date?: Date;
    esito?: string | undefined;

    constructor(data?: ICreaDiagnosiRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idPaziente = _data["idPaziente"];
            this.idPatologia = _data["idPatologia"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.esito = _data["esito"];
        }
    }

    static fromJS(data: any): CreaDiagnosiRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreaDiagnosiRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idPaziente"] = this.idPaziente;
        data["idPatologia"] = this.idPatologia;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["esito"] = this.esito;
        return data; 
    }
}

export interface ICreaDiagnosiRequest {
    idPaziente?: string | undefined;
    idPatologia?: string | undefined;
    date?: Date;
    esito?: string | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}